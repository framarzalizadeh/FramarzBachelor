% first example chapter
% @author Thomas Lehmann
%
\chapter{Technologischer Hintergrund}
\label{chap:technologie}
Dieses Kapitel stellt die konkreten Technologien vor, die für die Umsetzung 
des Prototyps verwendet wurden. Zunächst wird Make.com als zentrale 
Integrations- und Automatisierungsplattform erläutert. Anschließend folgt 
Airtable als Datenhaltung, gefolgt von Google Docs und Drive für 
Dokumentenerstellung und Ablage. Abschließend werden Lovable Cloud 
(Supabase Edge Functions) sowie der Frontend-Stack beschrieben.

\section{Make.com als Integrations- und Automatisierungsplattform}
\label{sec:make}

Make.com ist eine cloudbasierte Integrations- und Automatisierungsplattform,
die es ermöglicht, unterschiedliche Anwendungen, Dienste und Systeme
miteinander zu verbinden. Die Umsetzung erfolgt ohne klassische
Programmierung und basiert auf einem No-Code- beziehungsweise
Low-Code-Ansatz. Workflows werden in einer grafischen Benutzeroberfläche modelliert, indem vordefinierte Funktionsbausteine konfiguriert und zu logischen Abläufen
verknüpft werden. Dadurch können auch komplexe Integrationsprozesse ohne
umfangreiche Programmierkenntnisse umgesetzt werden. Aus technischer Sicht handelt es sich bei Make.com um eine Integrationsplattform, die externe Systeme über deren Web-\glspl{ac:api} anbindet. Ereignisse und Datenflüsse werden dabei in einem zentralen
Orchestrierungslayer zusammengeführt und automatisiert verarbeitet \cite{make_whatsapp_watch_events, make_array_aggregator}.

Das zentrale Konstrukt in Make sind sogenannte Szenarien. Ein Szenario
beschreibt einen vollständigen Automatisierungsablauf, der aus einem
auslösenden Ereignis (Trigger), einer Abfolge von Verarbeitungsschritten
sowie einer oder mehreren Aktionen besteht. Die einzelnen Bausteine eines Szenarios werden als Module bezeichnet.
Diese repräsentieren entweder konkrete Anwendungsintegrationen, etwa zu
WhatsApp, Airtable oder Google Docs, oder generische Funktionen wie Filter,
Iteratoren, Aggregatoren oder Router. Trigger-Module starten ein Szenario
beispielsweise bei einer eingehenden Nachricht über einen Webhook. Aktionsmodule übernehmen anschließend die Verarbeitung der Daten, indem
sie Informationen lesen, schreiben oder an andere Systeme übertragen.

\autoref{fig:make_scenario} zeigt ein typisches Make.com-Szenario zur Verarbeitung eingehender WhatsApp-Nachrichten. 
Dabei werden Daten in Airtable gespeichert, Rechnungen über Google Docs generiert und anschließend in Google Drive abgelegt.


\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{make_whatsapp_airtable.png}
\caption{Make.com-Szenario: WhatsApp-Trigger → Airtable → Google Docs → Drive.}
\label{fig:make_scenario}
\end{figure}

Mithilfe visueller Router und Filter können alternative Verarbeitungswege
modelliert werden, die abhängig von Dateninhalten oder Zuständen
unterschiedliche Pfade innerhalb des Szenarios durchlaufen \cite{make_array_aggregator}.

Die Plattform stellt darüber hinaus erweiterte Funktionen zur
Ablaufsteuerung bereit. Mithilfe von Filtern können nur jene Datensätze
weiterverarbeitet werden, die definierte Bedingungen erfüllen, etwa das
Vorhandensein bestimmter Pflichtfelder. Iteratoren und Aggregatoren ermöglichen die Verarbeitung von Listenstrukturen. Dabei können Datensätze entweder einzeln durchlaufen
oder zu zusammengefassten Ergebnissen aggregiert werden \cite{make_array_aggregator}. Router-Module
erlauben es, Workflows in mehrere Pfade zu verzweigen, die jeweils eigene
Bedingungen und nachgelagerte Verarbeitungsschritte besitzen. Auf diese Weise lassen sich auch komplexe und verzweigte Prozesse
modellieren, ohne dass eigener Kontrollfluss-Code implementiert werden
muss. Eine besondere Rolle nehmen Webhook-Trigger ein, da sie die nahezu
Echtzeit-Verarbeitung von Ereignissen aus externen Systemen ermöglichen,
sobald diese eine definierte URL aufrufen.

Im betrachteten Anwendungskontext fungiert Make.com als zentrale
Vermittlungsschicht zwischen Chatbot, Datenhaltung sowie Dokumenten- und
Speicherdiensten. Ereignisse aus der Kommunikationsschnittstelle werden
über Trigger-Module empfangen, innerhalb von Szenarien verarbeitet und
anschließend über Anwendungs-Module an Systeme wie Airtable, Google Docs
oder Google Drive weitergeleitet. Die Plattform übernimmt die zentrale Steuerung der Datenflüsse und führt während der Verarbeitung notwendige Validierungen aus. Anschließend werden nachgelagerte Aktionen ausgelöst, etwa die automatische Erzeugung von Dokumenten oder die Aktualisierung von Datensätzen in angebundenen Systemen. Make.com fungiert damit als Orchestrierungsschicht zwischen Chatbot, Datenhaltung und Dokumentenservices. Insbesondere für kleinere Projekte und prototypische Anwendungen ergeben sich daraus mehrere Vorteile: Die initiale Implementierung kann ohne
eigene Serverinfrastruktur erfolgen, vorgefertigte Konnektoren reduzieren
den Integrationsaufwand, und die Prozesslogik lässt sich durch die visuelle
Modellierung nachvollziehbar dokumentieren.

Gleichzeitig sind mit dem Einsatz einer Integrationsplattform wie Make.com
auch Einschränkungen verbunden. Sehr umfangreiche Szenarien können an
Übersichtlichkeit verlieren, da sämtliche Verarbeitungswege innerhalb
eines visuellen Diagramms abgebildet werden müssen. Zudem ist die
Abbildung komplexer Geschäftslogik nur eingeschränkt möglich. Darüber hinaus entsteht eine Abhängigkeit vom jeweiligen Anbieter, etwa
hinsichtlich Verfügbarkeit, Preisgestaltung und Funktionsumfang der
Plattform. Für hochskalierende oder besonders sicherheitskritische
Anwendungen kann daher eine klassisch implementierte, individuell
entwickelte Integrationsschicht sinnvoller sein. Make.com stellt hingegen insbesondere für klein- bis mittelkomplexe
Automatisierungsvorhaben mit begrenzten Ressourcen eine pragmatische und
gut nachvollziehbare Lösung dar.

Zusammenfassend steuern Make.com-Szenarien den Workflow vom WhatsApp-Trigger über Airtable bis zur Dokumentenerzeugung in Google Docs sowie zur Ablage in Google Drive.



\section{Airtable als Datenhaltung}
\label{sec:airtable}
Airtable ist eine cloudbasierte Plattform, die tabellenorientierte
Benutzeroberflächen mit den Eigenschaften einer datenbankgestützten
Anwendung kombiniert. Aus Anwendersicht ähnelt Airtable einer klassischen
Tabellenkalkulation, erweitert diese jedoch um strukturierte Feldtypen,
Relationen zwischen Tabellen sowie eine standardisierte
Programmierschnittstelle. Dadurch eignet sich die Plattform insbesondere für Anwendungsszenarien, in denen Daten sowohl über eine webbasierte Oberfläche gepflegt als auch automatisiert von externen Systemen gelesen und geschrieben werden sollen \cite{airtable_overview}.

Zentrale Konzepte in Airtable sind sogenannte Bases, die jeweils eine
in sich geschlossene Datenbankinstanz mit mehreren Tabellen
repräsentieren. Eine Tabelle besteht aus Datensätzen und Feldern, wobei
die Felder unterschiedliche Typen annehmen können, etwa Text, Zahl,
Datum, Auswahlfelder oder Verknüpfungen zu anderen Tabellen. Über verknüpfte Felder lassen sich einfache Relationen zwischen Tabellen modellieren, beispielsweise zwischen Kunden und zugehörigen Rechnungen. 

Eine beispielhafte Base-Struktur mit Kunden- und Rechnungstabellen ist in \autoref{fig:airtable_base} dargestellt.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{airtable_kunden_rechnungen.png}
\caption{Airtable Base mit Tabellen „Kunden" und „Rechnungen" (mit Filteransicht).}
\label{fig:airtable_base}
\end{figure}

Darüber hinaus stehen verschiedene Sichten und Filter zur Verfügung, mit denen Teilmengen der Daten anhand frei definierbarer Kriterien angezeigt werden können. Formelfelder ermöglichen zudem die Berechnung dynamischer Werte \cite{airtable_formula_guide}. Sie können unter anderem zur Aggregation von Beträgen oder zur Erzeugung
formatierter Anzeigeinhalte eingesetzt werden.

Für den Einsatz als zentrale Datenhaltung in einem verteilten System ist
insbesondere die von Airtable bereitgestellte \gls{ac:rest}-\gls{ac:api} von Bedeutung. Sie
ermöglicht es, Datensätze programmatisch anzulegen, zu aktualisieren, zu
löschen oder anhand definierter Filterkriterien abzufragen \cite{airtable_web_api_guide}. Auf diese Weise kann Airtable als zentrale \glqq Single Source of Truth\grqq{} für fachliche Informationen fungieren. Unterschiedliche Frontends und Automatisierungsprozesse greifen dabei über die \gls{ac:api} auf denselben
konsistenten Datenbestand zu. Durch die Kombination aus grafischer Benutzeroberfläche und Programmierschnittstelle eignet sich Airtable sowohl für die manuelle
Pflege und Kontrolle von Daten als auch für die Integration in
automatisierte Workflows.

Im Kontext kleiner, cloudbasierter Anwendungen bietet Airtable mehrere
Vorteile gegenüber klassischen Datenbanksystemen. Die Tabellenstruktur
kann ohne aufwendige Deployment- oder Migrationsprozesse angepasst
werden, was insbesondere iteratives Arbeiten und prototypische
Entwicklungen erleichtert. Darüber hinaus unterstützt die grafische Benutzeroberfläche die manuelle Datenpflege sowie die Fehlersuche. Datensätze sind unmittelbar einsehbar
und bearbeitbar, wodurch einfache Auswertungen und Kontrollen direkt in
der Anwendung durchgeführt werden können. Demgegenüber stehen typische Einschränkungen gehosteter Plattformen. Dazu zählen unter anderem Begrenzungen hinsichtlich des maximalen Datenvolumens, der Anzahl zulässiger \gls{ac:api}-Aufrufe sowie die fehlende Unterstützung komplexer Transaktionen. Für klein- bis mittelkomplexe Anwendungen mit moderatem Datenumfang stellt Airtable dennoch eine pragmatische Lösung dar. Es ermöglicht die Realisierung einer zentralen, cloudbasierten Datenhaltung, ohne dass eine eigene Datenbankinfrastruktur betrieben werden muss.

Die verwendete Airtable-Base umfasst vier Tabellen: \texttt{User\_Sessions} (Dialogzustand), \texttt{Customers}, \texttt{Rechnungen} und \texttt{Rechnungspositionen}.

\section{Google Docs und Google Drive}
\label{sec:google-docs-drive}
Google Docs und Google Drive sind zentrale Bestandteile der
Google-Workspace-Plattform und bilden gemeinsam eine cloudbasierte
Umgebung zur Erstellung, Bearbeitung und Ablage von Dokumenten. Google
Docs stellt einen webbasierten Texteditor bereit, der die gleichzeitige
Bearbeitung eines Dokuments durch mehrere Personen ermöglicht.
Google Drive fungiert als zentraler Dateispeicher und bietet strukturierte
Ordner, Freigabefunktionen sowie Versionsverwaltung. Beide Dienste sind
vollständig browserbasiert und erlauben einen orts- und
geräteunabhängigen Zugriff auf Dokumente, ohne dass eine lokale
Office-Software installiert werden muss.

Für automatisierte Systeme ist insbesondere die Programmierschnittstelle
von Google Docs von Bedeutung. Sie ermöglicht es, Dokumente nicht nur
manuell, sondern auch programmatisch zu erzeugen und zu verändern. In der Praxis werden hierzu häufig Dokumentvorlagen verwendet, die das
Layout sowie feste Textbestandteile definieren. Variable Inhalte werden
über Platzhalter integriert, die bei der Dokumentenerstellung durch
konkrete Werte aus einem Datensystem ersetzt werden.
Auf diese Weise können aus einer einzelnen Vorlage eine Vielzahl
individueller Dokumente generiert werden. Typische Anwendungsfälle sind
unter anderem die standardisierte Erstellung von Rechnungen, Angeboten
oder Serienbriefen, ohne dass jedes Dokument manuell angepasst werden
muss \cite{google_docs_api}.

Google Drive ergänzt diese Funktionalität durch eine strukturierte,
cloudbasierte Ablage der erzeugten Dokumente. Dateien können in
hierarchischen Ordnerstrukturen organisiert, mit Metadaten versehen und
über differenzierte Freigabemechanismen geteilt werden. Über die Google-Drive-\gls{ac:api} lassen sich Ordner und Dateien zudem programmgesteuert anlegen, verschieben, umbenennen oder herunterladen. Dadurch können Dokumentenerzeugung und Archivierung in einen
durchgängigen digitalen Prozess integriert werden. Insbesondere für kleinere Organisationen stellt Google Drive damit eine leichtgewichtige Alternative zu klassischen Dokumentenmanagementsystemen dar. Sowohl die manuelle Nutzung über die Weboberfläche als auch automatisierte Workflows auf Basis standardisierter Schnittstellen werden dabei unterstützt \cite{google_drive_api_guide}.

Google Docs erzeugt die Rechnungen auf Basis von Vorlagen, während Google Drive die Dokumente in einer hierarchischen Ordnerstruktur (Jahr/Quartal/Monat/Kunde) ablegt \cite{google_drive_org_guide}.


\section{Lovable Cloud / Supabase Edge Functions}
\label{sec:edge-functions}

Für die Webanwendung \glqq ClientHub\grqq{} wurde Lovable Cloud als Hosting- und Deployment-Umgebung verwendet. 
Serverseitige Logik wird dabei nicht über ein klassisches Backend mit dauerhaft laufendem Server umgesetzt, 
sondern über \emph{Supabase Edge Functions}. Diese Edge Functions sind serverlose \gls{ac:http}-Endpunkte, die bei Bedarf 
ausgeführt werden und sich besonders für leichte Integrations- und Proxy-Aufgaben eignen. Im Prototyp dienen 
sie insbesondere dazu, externe \glspl{ac:api} sicher anzubinden, ohne dass \gls{ac:api}-Schlüssel oder \gls{ac:oauth}-Geheimnisse im 
Frontend offengelegt werden müssen \cite{supabase_edge_functions}.

\subsection{Eingesetzte Edge Functions und Zweck}
Im Rahmen des Prototyps wurden zwei Edge Functions umgesetzt, die als Vermittlungsschicht zwischen Frontend 
und externen Diensten fungieren:

\begin{itemize}
  \item \texttt{airtable-customers}: Bereitstellung von \gls{ac:crud}-Operationen zur Abfrage und Verwaltung von Kundendaten in Airtable.
  \item \texttt{google-drive}: Umsetzung des \gls{ac:oauth}-2.0-Flows sowie Zugriff auf Ordner- und Dateiinformationen in Google Drive.
\end{itemize}

\subsection{Aufgerufene \glspl{ac:api}}
Die Edge Functions kapseln den Zugriff auf mehrere externe Schnittstellen. Für die Datenhaltung wird die 
Airtable \gls{ac:rest}-\gls{ac:api} genutzt (z.\,B.\ \texttt{api.airtable.com/v0/}). Für die Authentifizierung und den Zugriff 
auf Google Drive wird ein \gls{ac:oauth}-2.0-Flow verwendet, der u.\,a.\ Google-Endpoints wie 
\texttt{accounts.google.com} bzw.\ \texttt{oauth2.googleapis.com} einbindet. Der eigentliche Zugriff auf 
Ordner- und Dateistrukturen erfolgt anschließend über die Google-Drive-\gls{ac:api} v3 (z.\,B.\ 
\texttt{googleapis.com/drive/v3/files}).

\subsection{Zentrale Logik in den Edge Functions}
Die Implementierung der Edge Functions ist bewusst schlank gehalten und konzentriert sich auf das sichere 
Weiterreichen von Requests sowie die Normalisierung von Response-Daten.

\paragraph{Airtable: Kunden abrufen (Mapping)}
Die Edge Function \texttt{airtable-customers} ruft Datensätze über die Airtable-\gls{ac:api} ab und transformiert die 
Antwort in eine frontendfreundliche Struktur, indem \texttt{record.id} und \texttt{record.fields} zusammengeführt werden:

\begin{verbatim}
const response = await fetch(airtableUrl, {
  headers: { 'Authorization': `Bearer ${AIRTABLE_API_KEY}` },
});
const customers = data.records.map((record) => ({
  id: record.id,
  ...record.fields,
}));
\end{verbatim}

\paragraph{Google Drive: \gls{ac:oauth} Token Exchange}
Die Edge Function \texttt{google-drive} führt den Token-Austausch im \gls{ac:oauth}-2.0-Prozess serverseitig aus, um 
Client Secret und weitere vertrauliche Parameter zu schützen:

\begin{verbatim}
const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
  method: 'POST',
  body: new URLSearchParams({
    code, client_id, client_secret, redirect_uri,
    grant_type: 'authorization_code',
  }),
});
\end{verbatim}

\subsection{Begründung für Edge Functions}
Der Einsatz von Edge Functions bietet im Prototyp mehrere praktische Vorteile:

\begin{itemize}
  \item \textbf{Sicherheit:} \gls{ac:api}-Keys und \gls{ac:oauth}-Geheimnisse verbleiben serverseitig und sind nicht im Browser sichtbar.
  \item \textbf{\gls{ac:cors}-Entkopplung:} Direkte \gls{ac:api}-Calls aus dem Browser sind häufig durch \gls{ac:cors}-Restriktionen limitiert; die Edge Functions fungieren als kontrollierter Proxy.
  \item \textbf{Serverless-Betrieb:} Es ist kein eigener Server und kein klassisches Deployment/Scaling notwendig, da die Edge Functions ereignisbasiert und bedarfsgesteuert ausgeführt werden.
  \item \textbf{Geringe Latenz:} Ausführung am Edge kann zu geringeren Antwortzeiten führen, da Requests geographisch näher am Nutzer verarbeitet werden.
\end{itemize}

\subsection{Deployment und Konfiguration}
Die Edge Functions werden über die Supabase-Konfiguration aktiviert. Im Prototyp wurde die \gls{ac:jwt}-Verifikation 
deaktiviert, da die Endpunkte ausschließlich prototypisch und in einer kontrollierten Testumgebung genutzt 
wurden:

\begin{verbatim}
[functions.airtable-customers]
verify_jwt = false

[functions.google-drive]
verify_jwt = false
\end{verbatim}

Das Deployment erfolgt in Lovable Cloud automatisch durch Code-Änderungen, sodass kein manuelles Rollout 
erforderlich ist. Dadurch eignet sich der Ansatz besonders für iterative Prototypenentwicklung.

\subsection{Sicherheitsaspekte}
Ein zentraler Grund für die serverseitige Umsetzung ist die sichere Handhabung vertraulicher Zugangsdaten. 
\gls{ac:api}-Keys (z.\,B.\ Airtable) sowie \gls{ac:oauth}-Parameter (Client ID/Client Secret) werden als Secrets hinterlegt und 
nur innerhalb der Edge Functions verwendet. Zusätzlich können kontrollierte \gls{ac:cors}-Header gesetzt werden, um 
Zugriffe auf definierte Origins zu begrenzen. Im \gls{ac:oauth}-Kontext unterstützt der Ansatz außerdem eine saubere 
Token-Verwaltung (inkl.\ Refresh-Token-Mechanismus), ohne dass sensitive Daten im Frontend gespeichert werden müssen.

\subsection{Einordnung: Performance im Vergleich zu klassischem Backend}
Im Vergleich zu einem traditionellen Backend (dauerhaft laufender Server) sind Edge Functions typischerweise 
schnell verfügbar und skalieren automatisch pro Request. Während klassische Serverstarts bei Deployment oder 
Kaltstart-Situationen spürbare Verzögerungen verursachen können, sind serverlose Funktionen in der Regel für 
kurze, sporadische Integrationsaufgaben geeignet. Gleichzeitig bleiben Grenzen bestehen, z.\,B.\ durch 
Provider-Limits, Laufzeitbeschränkungen oder die Komplexität umfangreicher Geschäftslogik.
Edge Functions kapseln Airtable/Drive-Zugriffe sicher für ClientHub-Frontend.





\section{Frontend-Stack (React, TypeScript, Tailwind, shadcn/ui)}
\label{sec:frontend-stack}

Das Frontend der Webanwendung \glqq ClientHub\grqq{} wurde als moderne Single-Page-Application umgesetzt. 
Ziel war es, eine interaktive und übersichtliche Benutzeroberfläche bereitzustellen, die den Zugriff auf 
Kunden-, Rechnungs- und Dokumentendaten ermöglicht und dabei eng mit den serverseitigen Edge Functions 
zusammenarbeitet. Die technische Umsetzung basiert auf React in Kombination mit TypeScript sowie einem 
komponentenbasierten UI- und Styling-Ansatz.

\subsection{Grundlegende Technologien}
Als zentrales Framework kommt React in der Version 18.3.1 in Verbindung mit React DOM 18.3.1 zum Einsatz. 
React ermöglicht die deklarative Beschreibung von Benutzeroberflächen auf Basis wiederverwendbarer Komponenten 
und eignet sich insbesondere für datengetriebene Anwendungen mit häufigen Zustandsänderungen. 
Die Entwicklung erfolgt vollständig in TypeScript, wodurch eine statische Typisierung der Komponenten, 
Datenmodelle und Schnittstellen erreicht wird. Dies trägt zur besseren Wartbarkeit und zur frühzeitigen 
Erkennung typischer Fehler bei, etwa bei der Verarbeitung externer \gls{ac:api}-Daten.

\subsection{Routing und Zustandsverwaltung}
Die Navigation innerhalb der Anwendung wird über clientseitiges Routing realisiert. Hierfür wird 
\texttt{react-router-dom} (Version 6.30.1) eingesetzt, wodurch unterschiedliche Ansichten wie Dashboard, 
Kundenübersicht oder Dokumentenbrowser als Routen modelliert werden können, ohne dass ein vollständiger 
Seitenreload erforderlich ist.

Für den Umgang mit serverseitigen Daten wird TanStack Query (\texttt{@tanstack/react-query}, Version 5.83.0) 
verwendet. Diese Bibliothek abstrahiert wiederkehrende Aufgaben wie das Laden, Zwischenspeichern und 
Aktualisieren von Daten aus externen Quellen. Im Prototyp werden darüber unter anderem Kundendaten geladen, 
indem das Frontend eine Supabase Edge Function aufruft und die zurückgegebenen Datensätze als gecachten 
Server State innerhalb der Anwendung bereitstellt. Fehlerzustände und Ladeindikatoren werden dabei zentral 
verwaltet und konsistent in der Benutzeroberfläche dargestellt.

\subsection{Formularverarbeitung und Validierung}
Zur Umsetzung von Formularen, etwa bei der Anlage neuer Kunden, wird \texttt{react-hook-form} 
(Version 7.61.1) eingesetzt. Die Bibliothek ermöglicht eine performante Verwaltung von Formzuständen und 
reduziert unnötige Re-Renders. Ergänzend dazu wird \texttt{zod} (Version 3.25.76) zur schema-basierten 
Validierung genutzt. Eingabedaten können dadurch bereits im Frontend auf Vollständigkeit und Plausibilität 
geprüft werden, bevor sie an die serverseitigen Schnittstellen übermittelt werden.

Die zugrunde liegenden Datenstrukturen werden über TypeScript-Interfaces definiert, wodurch eine klare 
Trennung zwischen Anzeige-, Formular- und Transportdaten erreicht wird. Ein vereinfachtes Beispiel für ein 
Kundendatenmodell ist in folgendem Listing dargestellt:

\begin{verbatim}
export interface Customer {
  id: string;
  Firmenname?: string;
  name?: string;
  first_name?: string;
  "E-Mail"?: string;
  phone?: string;
  address?: string;
  city?: string;
  postal_code?: string;
  country?: string;
  ust_id?: string;
}
\end{verbatim}

\subsection{UI-Komponenten und Styling}
Für das visuelle Erscheinungsbild der Anwendung wird Tailwind CSS verwendet. Das Styling basiert auf einer 
stark angepassten Konfiguration mit eigenen Design-Tokens, die über CSS-Variablen definiert sind. 
Hierzu zählen unter anderem semantische Farbdefinitionen wie \glqq surface\grqq{}, \glqq success\grqq{} oder 
\glqq warning\grqq{} sowie Animationen für Übergänge und Interaktionen. Dieser Ansatz ermöglicht ein 
konsistentes Erscheinungsbild und erleichtert spätere Anpassungen des Designs.

Als Komponentenbibliothek wird \texttt{shadcn/ui} eingesetzt. Diese stellt vorgefertigte, barrierearme 
UI-Komponenten bereit, die direkt im Projektcode integriert und bei Bedarf angepasst werden können. 
Im Prototyp kommen unter anderem Layout-Komponenten wie Cards und Tabs, Formularelemente wie Buttons, Inputs 
und Selects sowie Feedback-Elemente wie Dialoge, Alerts und Toasts zum Einsatz. Die Kombination aus Tailwind 
CSS und shadcn/ui erlaubt eine flexible Gestaltung bei gleichzeitig hoher Konsistenz der Benutzeroberfläche.

\subsection{Struktur und Datenfluss im Frontend}
Die Codebasis des Frontends ist modular aufgebaut und nach fachlichen sowie technischen Aspekten strukturiert. 
Neben allgemeinen Layout- und UI-Komponenten existieren eigenständige Module für Kundenverwaltung, Dashboard 
und Dokumentenbrowser. Wiederkehrende Logik, etwa für das Laden von Kundendaten, ist in dedizierten Hooks 
gekapselt. Der Zugriff auf serverseitige Funktionen erfolgt ausschließlich über den Supabase-Client, der 
\gls{ac:http}-Aufrufe an die entsprechenden Edge Functions kapselt und deren Antworten an das Frontend zurückliefert.

\subsection{Responsives Design und Einschränkungen}
Das Layout der Anwendung ist teilweise responsiv umgesetzt. Grid-Strukturen und Breakpoints werden genutzt, 
um Inhalte auf unterschiedlichen Bildschirmgrößen sinnvoll anzuordnen. Der Fokus der aktuellen Umsetzung 
liegt jedoch auf der Desktop-Nutzung; insbesondere die Sidebar-Navigation ist nicht vollständig für mobile 
Endgeräte optimiert. Diese Einschränkung wurde bewusst in Kauf genommen, da der Prototyp primär für den 
Einsatz in einer Desktop-orientierten Arbeitsumgebung konzipiert ist.

\subsection{Deployment des Frontends}
Das Frontend wird über Lovable Cloud bereitgestellt. Der Build erfolgt als Vite-Produktionsbuild, der 
anschließend automatisch veröffentlicht wird. Änderungen am Code führen ohne manuelle Eingriffe zu einem 
neuen Deployment. Die Webanwendung ist sowohl über eine Preview- als auch über eine veröffentlichte URL 
erreichbar. Die enge Verzahnung mit den serverseitigen Edge Functions ermöglicht dabei einen durchgängigen 
End-to-End-Betrieb der Anwendung.
ClientHub verbindet damit das React-Frontend über Edge Functions mit Airtable und Google Drive und stellt eine einheitliche Verwaltungsoberfläche bereit.

